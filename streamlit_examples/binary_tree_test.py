from collections import deque

# Generated by Anthropic Chain of Reasoning
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# fully recursive version
def invert_tree_recursive(root):
    if not root:
        return None
    # Swap the left and right children
    root.left, root.right = root.right, root.left
    # Recursively invert the left and right subtrees
    invert_tree_recursive(root.left)
    invert_tree_recursive(root.right)
    return root

# looped version using deque
def invert_tree_level_order(root):
    if not root:
        return None
    queue = deque([root])
    while queue:
        node = queue.popleft() # Swap the left and right children
        node.left, node.right = node.right, node.left
        # Add non-null children to the queue
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right) 
    return root

# own code, jsut to print the tree recursively
def print_tree(root):
    if not root:
        return
    print(root.val)
    print_tree(root.left)
    print_tree(root.right)

def main():
    # Input: [4,2,7,1,3,6,9]
    # Output: [4,7,2,9,6,3,1]
    root = TreeNode(4)
    root.left = TreeNode(2)
    root.right = TreeNode(7)
    root.left.left = TreeNode(1)
    root.left.right = TreeNode(3)
    root.right.left = TreeNode(6)
    root.right.right = TreeNode(9)
    result = invert_tree_recursive(root)
    print_tree(result)

    root = TreeNode(4)
    root.left = TreeNode(2)
    root.right = TreeNode(7)
    root.left.left = TreeNode(1)
    root.left.right = TreeNode(3)
    root.right.left = TreeNode(6)
    root.right.right = TreeNode(9)
    result = invert_tree_level_order(root)
    print_tree(result)

if __name__ == "__main__":
    main()
